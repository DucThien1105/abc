{"ast":null,"code":"import _wrapAsyncGenerator from \"C:/Angular/Angular-AHT/AA/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _awaitAsyncGenerator from \"C:/Angular/Angular-AHT/AA/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _asyncGeneratorDelegate from \"C:/Angular/Angular-AHT/AA/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate\";\n\nfunction _asyncIterator(r) { var n, t, o, e = 2; for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = \"@@asyncIterator\", o = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }\n\nimport { statSync, createReadStream, promises as fs } from 'node:fs';\nimport { basename } from 'node:path';\nimport DOMException from 'node-domexception';\nimport File from './file.js';\nimport Blob from './index.js';\nconst {\n  stat\n} = fs;\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\n\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type);\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\n\n\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\n\n\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\n\n\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type); // @ts-ignore\n\n\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], {\n  type\n}); // @ts-ignore\n\n\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), {\n  type,\n  lastModified: stat.mtimeMs\n});\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\n\n\nclass BlobDataItem {\n  #path;\n  #start;\n\n  constructor(options) {\n    this.#path = options.path;\n    this.#start = options.start;\n    this.size = options.size;\n    this.lastModified = options.lastModified;\n  }\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n\n\n  slice(start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    });\n  }\n\n  stream() {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const {\n        mtimeMs\n      } = yield _awaitAsyncGenerator(stat(_this.#path));\n\n      if (mtimeMs > _this.lastModified) {\n        throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError');\n      }\n\n      yield* _asyncGeneratorDelegate(_asyncIterator(createReadStream(_this.#path, {\n        start: _this.#start,\n        end: _this.#start + _this.size - 1\n      })), _awaitAsyncGenerator);\n    })();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n\n}\n\nexport default blobFromSync;\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync };","map":{"version":3,"sources":["C:/Angular/Angular-AHT/AA/node_modules/fetch-blob/from.js"],"names":["statSync","createReadStream","promises","fs","basename","DOMException","File","Blob","stat","blobFromSync","path","type","fromBlob","blobFrom","then","fileFrom","fromFile","fileFromSync","BlobDataItem","size","lastModified","mtimeMs","start","constructor","options","slice","end","stream","Symbol","toStringTag"],"mappings":"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","sourcesContent":["import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n"]},"metadata":{},"sourceType":"module"}