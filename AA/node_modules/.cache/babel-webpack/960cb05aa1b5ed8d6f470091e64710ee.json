{"ast":null,"code":"import _asyncToGenerator from \"C:/Angular/Angular-AHT/AA/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction _asyncIterator(r) { var n, t, o, e = 2; for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = \"@@asyncIterator\", o = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }\n\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\nimport Stream, { PassThrough } from 'node:stream';\nimport { types, deprecate, promisify } from 'node:util';\nimport { Buffer } from 'node:buffer';\nimport Blob from 'fetch-blob';\nimport { FormData, formDataToBlob } from 'formdata-polyfill/esm.min.js';\nimport { FetchError } from './errors/fetch-error.js';\nimport { FetchBaseError } from './errors/base.js';\nimport { isBlob, isURLSearchParameters } from './utils/is.js';\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\n\nexport default class Body {\n  constructor(body, {\n    size = 0\n  } = {}) {\n    let boundary = null;\n\n    if (body === null) {\n      // Body is undefined or null\n      body = null;\n    } else if (isURLSearchParameters(body)) {\n      // Body is a URLSearchParams\n      body = Buffer.from(body.toString());\n    } else if (isBlob(body)) {// Body is blob\n    } else if (Buffer.isBuffer(body)) {// Body is Buffer\n    } else if (types.isAnyArrayBuffer(body)) {\n      // Body is ArrayBuffer\n      body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n      // Body is ArrayBufferView\n      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof Stream) {// Body is stream\n    } else if (body instanceof FormData) {\n      // Body is FormData\n      body = formDataToBlob(body);\n      boundary = body.type.split('=')[1];\n    } else {\n      // None of the above\n      // coerce to string then buffer\n      body = Buffer.from(String(body));\n    }\n\n    let stream = body;\n\n    if (Buffer.isBuffer(body)) {\n      stream = Stream.Readable.from(body);\n    } else if (isBlob(body)) {\n      stream = Stream.Readable.from(body.stream());\n    }\n\n    this[INTERNALS] = {\n      body,\n      stream,\n      boundary,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n\n    if (body instanceof Stream) {\n      body.on('error', error_ => {\n        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n\n  get body() {\n    return this[INTERNALS].stream;\n  }\n\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n\n\n  arrayBuffer() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        buffer,\n        byteOffset,\n        byteLength\n      } = yield consumeBody(_this);\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    })();\n  }\n\n  formData() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const ct = _this2.headers.get('content-type');\n\n      if (ct.startsWith('application/x-www-form-urlencoded')) {\n        const formData = new FormData();\n        const parameters = new URLSearchParams(yield _this2.text());\n\n        for (const [name, value] of parameters) {\n          formData.append(name, value);\n        }\n\n        return formData;\n      }\n\n      const {\n        toFormData\n      } = yield import('./utils/multipart-parser.js');\n      return toFormData(_this2.body, ct);\n    })();\n  }\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n\n\n  blob() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const ct = _this3.headers && _this3.headers.get('content-type') || _this3[INTERNALS].body && _this3[INTERNALS].body.type || '';\n      const buf = yield _this3.arrayBuffer();\n      return new Blob([buf], {\n        type: ct\n      });\n    })();\n  }\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n\n\n  json() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const text = yield _this4.text();\n      return JSON.parse(text);\n    })();\n  }\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n\n\n  text() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const buffer = yield consumeBody(_this5);\n      return new TextDecoder().decode(buffer);\n    })();\n  }\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n\n\n  buffer() {\n    return consumeBody(this);\n  }\n\n}\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer'); // In browsers, all properties are enumerable.\n\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  },\n  data: {\n    get: deprecate(() => {}, 'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (response)')\n  }\n});\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\n\nfunction consumeBody(_x) {\n  return _consumeBody.apply(this, arguments);\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\n\n\nfunction _consumeBody() {\n  _consumeBody = _asyncToGenerator(function* (data) {\n    if (data[INTERNALS].disturbed) {\n      throw new TypeError(`body used already for: ${data.url}`);\n    }\n\n    data[INTERNALS].disturbed = true;\n\n    if (data[INTERNALS].error) {\n      throw data[INTERNALS].error;\n    }\n\n    const {\n      body\n    } = data; // Body is null\n\n    if (body === null) {\n      return Buffer.alloc(0);\n    }\n    /* c8 ignore next 3 */\n\n\n    if (!(body instanceof Stream)) {\n      return Buffer.alloc(0);\n    } // Body is stream\n    // get ready to actually consume the body\n\n\n    const accum = [];\n    let accumBytes = 0;\n\n    try {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(body), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const chunk = _value;\n\n          if (data.size > 0 && accumBytes + chunk.length > data.size) {\n            const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n            body.destroy(error);\n            throw error;\n          }\n\n          accumBytes += chunk.length;\n          accum.push(chunk);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } catch (error) {\n      const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n      throw error_;\n    }\n\n    if (body.readableEnded === true || body._readableState.ended === true) {\n      try {\n        if (accum.every(c => typeof c === 'string')) {\n          return Buffer.from(accum.join(''));\n        }\n\n        return Buffer.concat(accum, accumBytes);\n      } catch (error) {\n        throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n      }\n    } else {\n      throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n    }\n  });\n  return _consumeBody.apply(this, arguments);\n}\n\nexport const clone = (instance, highWaterMark) => {\n  let p1;\n  let p2;\n  let {\n    body\n  } = instance[INTERNALS]; // Don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // Check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // Tee instance body\n    p1 = new PassThrough({\n      highWaterMark\n    });\n    p2 = new PassThrough({\n      highWaterMark\n    });\n    body.pipe(p1);\n    body.pipe(p2); // Set instance body to teed body and return the other teed body\n\n    instance[INTERNALS].stream = p1;\n    body = p2;\n  }\n\n  return body;\n};\nconst getNonSpecFormDataBoundary = deprecate(body => body.getBoundary(), 'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package', 'https://github.com/node-fetch/node-fetch/issues/1167');\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\n\nexport const extractContentType = (body, request) => {\n  // Body is null or undefined\n  if (body === null) {\n    return null;\n  } // Body is string\n\n\n  if (typeof body === 'string') {\n    return 'text/plain;charset=UTF-8';\n  } // Body is a URLSearchParams\n\n\n  if (isURLSearchParameters(body)) {\n    return 'application/x-www-form-urlencoded;charset=UTF-8';\n  } // Body is blob\n\n\n  if (isBlob(body)) {\n    return body.type || null;\n  } // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\n\n  if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n    return null;\n  }\n\n  if (body instanceof FormData) {\n    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getBoundary === 'function') {\n    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n  } // Body is stream - can't really do much about this\n\n\n  if (body instanceof Stream) {\n    return null;\n  } // Body constructor defaults other things to string\n\n\n  return 'text/plain;charset=UTF-8';\n};\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\n\nexport const getTotalBytes = request => {\n  const {\n    body\n  } = request[INTERNALS]; // Body is null or undefined\n\n  if (body === null) {\n    return 0;\n  } // Body is Blob\n\n\n  if (isBlob(body)) {\n    return body.size;\n  } // Body is Buffer\n\n\n  if (Buffer.isBuffer(body)) {\n    return body.length;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getLengthSync === 'function') {\n    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n  } // Body is stream\n\n\n  return null;\n};\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\n\nexport const writeToStream = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (dest, {\n    body\n  }) {\n    if (body === null) {\n      // Body is null\n      dest.end();\n    } else {\n      // Body is stream\n      yield pipeline(body, dest);\n    }\n  });\n\n  return function writeToStream(_x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["C:/Angular/Angular-AHT/AA/node_modules/node-fetch/src/body.js"],"names":["Stream","PassThrough","types","deprecate","promisify","Buffer","Blob","FormData","formDataToBlob","FetchError","FetchBaseError","isBlob","isURLSearchParameters","pipeline","INTERNALS","Symbol","Body","constructor","body","size","boundary","from","toString","isBuffer","isAnyArrayBuffer","ArrayBuffer","isView","buffer","byteOffset","byteLength","type","split","String","stream","Readable","disturbed","error","on","error_","url","message","bodyUsed","arrayBuffer","consumeBody","slice","formData","ct","headers","get","startsWith","parameters","URLSearchParams","text","name","value","append","toFormData","blob","buf","json","JSON","parse","TextDecoder","decode","prototype","Object","defineProperties","enumerable","data","TypeError","alloc","accum","accumBytes","chunk","length","destroy","push","readableEnded","_readableState","ended","every","c","join","concat","clone","instance","highWaterMark","p1","p2","Error","getBoundary","pipe","getNonSpecFormDataBoundary","extractContentType","request","getTotalBytes","getLengthSync","hasKnownLength","writeToStream","dest","end"],"mappings":"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","sourcesContent":["\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'node:stream';\nimport {types, deprecate, promisify} from 'node:util';\nimport {Buffer} from 'node:buffer';\n\nimport Blob from 'fetch-blob';\nimport {FormData, formDataToBlob} from 'formdata-polyfill/esm.min.js';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {isBlob, isURLSearchParameters} from './utils/is.js';\n\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (body instanceof FormData) {\n\t\t\t// Body is FormData\n\t\t\tbody = formDataToBlob(body);\n\t\t\tboundary = body.type.split('=')[1];\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tlet stream = body;\n\n\t\tif (Buffer.isBuffer(body)) {\n\t\t\tstream = Stream.Readable.from(body);\n\t\t} else if (isBlob(body)) {\n\t\t\tstream = Stream.Readable.from(body.stream());\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tstream,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].stream;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\tasync formData() {\n\t\tconst ct = this.headers.get('content-type');\n\n\t\tif (ct.startsWith('application/x-www-form-urlencoded')) {\n\t\t\tconst formData = new FormData();\n\t\t\tconst parameters = new URLSearchParams(await this.text());\n\n\t\t\tfor (const [name, value] of parameters) {\n\t\t\t\tformData.append(name, value);\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\tconst {toFormData} = await import('./utils/multipart-parser.js');\n\t\treturn toFormData(this.body, ct);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.arrayBuffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst text = await this.text();\n\t\treturn JSON.parse(text);\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true},\n\tdata: {get: deprecate(() => {},\n\t\t'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead',\n\t\t'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tconst {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance[INTERNALS];\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].stream = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\nconst getNonSpecFormDataBoundary = deprecate(\n\tbody => body.getBoundary(),\n\t'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package',\n\t'https://github.com/node-fetch/node-fetch/issues/1167'\n);\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\tif (body instanceof FormData) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request[INTERNALS];\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\nexport const writeToStream = async (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tawait pipeline(body, dest);\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}